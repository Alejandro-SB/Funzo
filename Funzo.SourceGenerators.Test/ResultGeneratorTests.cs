using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Reflection;

namespace Funzo.SourceGenerators.Test;

public class ResultGeneratorTests
{
    [Fact]
    public void Test1()
    {
        const string input = $@"
using Funzo;
using Bar;
using Foo.Bar;

namespace Foo.Bar 
{{
    public class Class1
    {{
    }}
}}

namespace Bar 
{{
    public class Class2
    {{
    }}
}}

namespace Foo
{{
    [Result]
    partial class FooBar : Result<Class1, Class2> {{ }}
}}
";

        const string expectedCode = @"// <auto-generated />
#pragma warning disable 1591

namespace Foo
{
    partial class FooBar
    {
        
    }
}";

        AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(input, expectedCode, "Foo_FooBar.g.cs");
    }

    private static void AssertCorrectSourceCodeIsGeneratedWithNoDiagnostics(string inputSource, string expectedCode, string generatedFileName, int expectedCompilationFileCount = 3)
    {
        var parsedAttribute = CSharpSyntaxTree.ParseText(expectedCode);

        var inputCompilation = CreateCompilation(inputSource);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ResultGenerator());

        driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);

        Assert.True(diagnostics.IsEmpty);

        Assert.Equal(expectedCompilationFileCount, outputCompilation.SyntaxTrees.Count());

        Assert.Empty(outputCompilation.GetDiagnostics());

        var compiledAttribute = outputCompilation.SyntaxTrees.Single(e => e.FilePath.Contains(generatedFileName));

        Assert.True(parsedAttribute.IsEquivalentTo(compiledAttribute));

        Assert.True(outputCompilation.GetDiagnostics().IsEmpty);
    }

    private static Compilation CreateCompilation(string source)
    {
        var references = new List<MetadataReference>
            {
                MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Result<,>).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(AppDomain.CurrentDomain.GetAssemblies().Single(a => a.GetName().Name == "netstandard").Location)
            };

        //https://github.com/dotnet/roslyn/issues/49498#issuecomment-734452762
        foreach (var assembly in Assembly.GetEntryAssembly()!.GetReferencedAssemblies())
        {
            references.Add(MetadataReference.CreateFromFile(Assembly.Load(assembly).Location));
        }

        return CSharpCompilation.Create("compilation", [CSharpSyntaxTree.ParseText(source)], references, new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }
}
