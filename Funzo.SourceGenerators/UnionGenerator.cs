using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace Funzo.SourceGenerators;
[Generator]
public class UnionGenerator : IIncrementalGenerator
{
    private const string AttributeName = "UnionAttribute";
    private const string AttributeNamespace = "Funzo";
    private const string AttributeFullName = $"{AttributeNamespace}.{AttributeName}";

    private const string AttributeContent = $@"// <auto-generated />
using System;

#pragma warning disable 1591

namespace {AttributeNamespace}
{{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class {AttributeName} : Attribute
    {{
    }}
}}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs", AttributeContent));

        var unionClasses = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeFullName,
                IsSyntaxTargetForGeneration,
                GetSemanticTargetForGeneration)
            .Where(static m => m is not null)
            .Collect();

        context.RegisterSourceOutput(unionClasses, Execute);


        static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken _)
            => node is ClassDeclarationSyntax classDeclarationSyntax
                   && classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);

        static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            var symbol = context.TargetSymbol;

            if (symbol is not INamedTypeSymbol namedTypeSymbol)
            {
                return null;
            }

            var hasAttribute = namedTypeSymbol.GetAttributes().Any(ad =>
                string.Equals(ad.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), $"global::{AttributeNamespace}.{AttributeName}"));

            return hasAttribute ? namedTypeSymbol : null;
        }
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> symbols)
    {
        foreach (var namedTypeSymbol in symbols.Where(symbol => symbol is not null))
        {
            var classSource = ProcessClass(namedTypeSymbol!, context);

            if (classSource is null)
            {
                continue;
            }

            context.AddSource($"{namedTypeSymbol!.ContainingNamespace}_{namedTypeSymbol.Name}.g.cs", classSource);
        }
    }

    private static string? ProcessClass(INamedTypeSymbol classSymbol, SourceProductionContext context)
    {
        var attributeLocation = classSymbol.Locations.FirstOrDefault() ?? Location.None;

        if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            CreateDiagnosticError(FunzoDiagnosticDescriptors.Union.TopLevelError);
            return null;
        }

        if (classSymbol.BaseType is null || classSymbol.BaseType.Name != "Union" || classSymbol.BaseType.ContainingNamespace.ToString() != "Funzo")
        {
            CreateDiagnosticError(FunzoDiagnosticDescriptors.Union.WrongBaseType);
            return null;
        }

        var typeArguments = classSymbol.BaseType.TypeArguments;

        foreach (var typeSymbol in typeArguments)
        {
            if (typeSymbol.Name == nameof(Object))
            {
                CreateDiagnosticError(FunzoDiagnosticDescriptors.Union.ObjectNotValidType);
                return null;
            }

            if (typeSymbol.TypeKind == TypeKind.Interface)
            {
                CreateDiagnosticError(FunzoDiagnosticDescriptors.Union.InterfaceNotValidType);
                return null;
            }
        }

        return GenerateClassSource(classSymbol, classSymbol.BaseType.TypeParameters, typeArguments);

        void CreateDiagnosticError(DiagnosticDescriptor descriptor)
        {
            context.ReportDiagnostic(Diagnostic.Create(descriptor, attributeLocation, classSymbol.Name,
                DiagnosticSeverity.Error));
        }
    }

    private static string GetGenerics(ImmutableArray<ITypeSymbol> typeArguments) =>
        string.Join(", ", typeArguments.Select(x => x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));

    private static string? GetOpenGenericPart(INamedTypeSymbol classSymbol)
    {
        if (!classSymbol.TypeArguments.Any())
        {
            return null;
        }

        return $"<{GetGenerics(classSymbol.TypeArguments)}>";
    }

    private static string GenerateClassSource(INamedTypeSymbol classSymbol,
        ImmutableArray<ITypeParameterSymbol> typeParameters, ImmutableArray<ITypeSymbol> typeArguments)
    {
        var unionGenerics = GetGenerics(typeArguments);

        var classNameWithGenericTypes = $"{classSymbol.Name}{GetOpenGenericPart(classSymbol)}";

        StringBuilder source = new($@"// <auto-generated />

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{
    partial class {classNameWithGenericTypes}
    {{");

        foreach (var type in typeArguments)
        {
            source.Append($@"
        public {classSymbol.Name}({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) : base(_) {{}}
        public static implicit operator {classNameWithGenericTypes}({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) => new {classNameWithGenericTypes}(_);
");
        }

        source.Append(@"    }
}");

        var src = source.ToString();
        return src;
    }
}