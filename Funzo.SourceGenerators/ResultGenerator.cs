using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace Funzo.SourceGenerators
{
    [Generator]
    public class ResultGenerator : IIncrementalGenerator
    {
        private const string AttributeName = "ResultAttribute";
        private const string AttributeNamespace = "Funzo";
        private const string AttributeFullName = $"{AttributeNamespace}.{AttributeName}";

        private const string AttributeContent = $@"// <auto-generated />
using System;

#pragma warning disable 1591

namespace {AttributeNamespace}
{{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class {AttributeName} : Attribute
    {{
    }}
}}
";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs", AttributeContent));

            var resultClasses = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    AttributeFullName,
                    IsSyntaxTargetForGeneration,
                    GetSemanticTargetForGeneration)
                .Where(static m => m is not null)
                .Collect();

            context.RegisterSourceOutput(resultClasses, Execute);


            static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken _)
                => node is ClassDeclarationSyntax classDeclarationSyntax
                       && classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);

            static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
            {
                var symbol = context.TargetSymbol;

                if (symbol is not INamedTypeSymbol namedTypeSymbol)
                {
                    return null;
                }

                var hasAttribute = namedTypeSymbol.GetAttributes().Any(ad =>
                    string.Equals(ad.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), $"global::{AttributeNamespace}.{AttributeName}"));

                return hasAttribute ? namedTypeSymbol : null;
            }
        }

        private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> symbols)
        {
            foreach (var namedTypeSymbol in symbols.Where(symbol => symbol is not null))
            {
                var classSource = ProcessClass(namedTypeSymbol!, context);

                if (classSource is null)
                {
                    continue;
                }

                context.AddSource($"{namedTypeSymbol!.ContainingNamespace}_{namedTypeSymbol.Name}.g.cs", classSource);
            }
        }

        private static string? ProcessClass(INamedTypeSymbol classSymbol, SourceProductionContext context)
        {
            var attributeLocation = classSymbol.Locations.FirstOrDefault() ?? Location.None;

            if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            {
                CreateDiagnosticError(FunzoDiagnosticDescriptors.Result.TopLevelError);
                return null;
            }

            var resultInterfaceType = classSymbol.Interfaces.FirstOrDefault(i => i.Name == "IResult" && i.ContainingNamespace.Name == "Funzo");

            if (classSymbol.BaseType is null || classSymbol.BaseType.Name != "Object" || resultInterfaceType is null)
            {
                CreateDiagnosticError(FunzoDiagnosticDescriptors.Result.WrongBaseType);
                return null;
            }

            var typeArguments = resultInterfaceType.TypeArguments;

            foreach (var typeSymbol in typeArguments)
            {
                if (typeSymbol.Name == nameof(Object))
                {
                    CreateDiagnosticError(FunzoDiagnosticDescriptors.Result.ObjectNotValidType);
                    return null;
                }
            }

            return GenerateClassSource(classSymbol, typeArguments);

            void CreateDiagnosticError(DiagnosticDescriptor descriptor)
            {
                context.ReportDiagnostic(Diagnostic.Create(descriptor, attributeLocation, classSymbol.Name,
                    DiagnosticSeverity.Error));
            }
        }

        private static string GetGenerics(ImmutableArray<ITypeSymbol> typeArguments) =>
            string.Join(", ", typeArguments.Select(x => x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));

        private static string? GetOpenGenericPart(INamedTypeSymbol classSymbol)
        {
            if (!classSymbol.TypeArguments.Any())
            {
                return null;
            }

            return $"<{GetGenerics(classSymbol.TypeArguments)}>";
        }

        private static string GenerateClassSource(INamedTypeSymbol classSymbol, ImmutableArray<ITypeSymbol> typeArguments)
        {
            var isSimpleResult = typeArguments.Length == 1;
            var (okArgs, errArgs) = isSimpleResult
                // TODO: Split logic between <TErr> and <TOk, TErr> cases
                ? (typeArguments[0], typeArguments[0])
                : (typeArguments[0], typeArguments[1]);

            var classNameWithGenericTypes = $"{classSymbol.Name}{GetOpenGenericPart(classSymbol)}";

            var okDisplayName = okArgs.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var errDisplayName = errArgs.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            StringBuilder source = new($@"// <auto-generated />

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{");
            // Class definition
            if (isSimpleResult)
            {
                source.Append($@"
    partial class {classNameWithGenericTypes} : ResultBase<{classSymbol.Name},{errDisplayName}>, IResultBase<{classSymbol.Name},{errDisplayName}> ");
            }
            else
            {
                source.Append($@"
    partial class {classNameWithGenericTypes} : ResultBase<{classSymbol.Name}, {okDisplayName},{errDisplayName}>, IResultBase<{classSymbol.Name}, {okDisplayName},{errDisplayName}> ");
            }
            source.Append($@"
    {{");


            if (isSimpleResult)
            {
                source.Append($@"
        protected {classSymbol.Name}() : base() {{}}
        public static {classNameWithGenericTypes} Ok() => new();");
            }
            else
            {
                source.Append($@"
        protected {classSymbol.Name}({okDisplayName} _) : base(_) {{}}
        public static {classNameWithGenericTypes} Ok({okDisplayName} ok) => new(ok);
        public static implicit operator {classNameWithGenericTypes}({okDisplayName} _) => new {classNameWithGenericTypes}(_);
                ");
            }

            source.Append($@"
        protected {classSymbol.Name}({errDisplayName} _) : base(_) {{}}
        public static implicit operator {classNameWithGenericTypes}({errDisplayName} _) => new {classNameWithGenericTypes}(_);
        public static {classNameWithGenericTypes} Err({errDisplayName} err) => new(err);
");

            if (isSimpleResult)
            {
                source.Append(@$"
        public static IResultBuilder<{classSymbol.Name}, {errDisplayName}> For() => new ResultBuilder<{classSymbol.Name}, {errDisplayName}>();
");
            }
            else
            {
                source.Append(@$"
        public static IResultBuilder<{classSymbol.Name}, {okDisplayName}, {errDisplayName}> For() => new ResultBuilder<{classSymbol.Name}, {okDisplayName}, {errDisplayName}>();
");
            }

            source.Append(@"    }
}");

            var src = source.ToString();

            return src;
        }
    }
}
