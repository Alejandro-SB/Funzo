using Funzo.SourceGenerators.Generators.Results;
using Funzo.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Linq;
using System.Text;

namespace Funzo.SourceGenerators.Generators;

internal class ResultSourceGenerator : SourceGeneratorBase
{
    internal override string? GetSource(SourceProductionContext context, SymbolWithAttribute symbolWithAttribute)
    {
        if (HasErrors(context, symbolWithAttribute))
        {
            return null;
        }

        var isSimpleResult = symbolWithAttribute.TypeArguments.Length == 1;

        Results.ResultGenerator generator = isSimpleResult
            ? new Result1AritySourceGenerator(symbolWithAttribute)
            : new Result2AritySourceGenerator(symbolWithAttribute);

        var containingType = symbolWithAttribute.Symbol.ContainingType?.Name;

        var sb = new StringBuilder($@"// <auto-generated />

namespace {symbolWithAttribute.Symbol.ContainingNamespace.ToDisplayString()}
{{");

        if (containingType is not null)
        {
            var isStatic = symbolWithAttribute.Symbol.ContainingType!.IsStatic ? "static " : "";
            sb.AppendLine($"{isStatic}partial class {containingType} {{");
        }

        sb.AppendLine($@"
        {generator.ClassDefinition}
    {{
        {generator.OkConstructor}
        {generator.OkStaticHelper}
        {generator.OkImplicitConverter}
        {generator.ErrConstructor}
        {generator.ErrStaticHelper}
        {generator.ErrImplicitConverter}
    }}
}}");

        if (containingType is not null)
        {
            sb.AppendLine("}");
        }

        var src = sb.ToString();

        return src;
    }

    private bool HasErrors(SourceProductionContext context, SymbolWithAttribute symbolWithAttribute)
    {
        var (ClassSymbol, _) = symbolWithAttribute;

        if (!ClassSymbol.ContainingSymbol.Equals(ClassSymbol.ContainingNamespace, SymbolEqualityComparer.Default) && ClassSymbol.ContainingType is { } containerType
           && containerType.DeclaringSyntaxReferences.Any(syntax =>
               syntax.GetSyntax() is BaseTypeDeclarationSyntax declaration
               && !declaration.Modifiers.Any(mod => mod.IsKind(SyntaxKind.PartialKeyword))))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Result.TopLevelError, ClassSymbol);
            return true;
        }

        if (ClassSymbol.BaseType is not null && ClassSymbol.BaseType.Name != "Object")
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Result.WrongBaseType, ClassSymbol);
            return true;
        }

        foreach (var typeSymbol in symbolWithAttribute.TypeArguments)
        {
            if (typeSymbol.Name == nameof(Object))
            {
                CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Result.ObjectNotValidType, ClassSymbol);
                return true;
            }
        }

        return false;
    }
}
