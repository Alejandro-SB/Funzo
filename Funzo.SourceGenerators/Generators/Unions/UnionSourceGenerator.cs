using Funzo.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Funzo.SourceGenerators.Generators.Unions;

internal class UnionSourceGenerator : SourceGeneratorBase
{
    internal override string? GetSource(SourceProductionContext context, SymbolWithAttribute symbolWithAttribute)
    {
        if (HasErrors(context, symbolWithAttribute))
        {
            return null;
        }

        var commonProperties = GetCommonProperties(symbolWithAttribute.TypeArguments);

        var (classSymbol, _) = symbolWithAttribute;
        var className = $"{classSymbol.Name}";
        var typeArguments = symbolWithAttribute.TypeArguments;

        StringBuilder source = new($@"// <auto-generated />

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{
    partial class {className} : Union{typeArguments.OpenGenericPart()}
    {{");

        foreach (var type in typeArguments)
        {
            source.Append($@"
        public {classSymbol.Name}({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) : base(_) {{}}
        public static implicit operator {className}({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) => new {className}(_);
");
        }

        foreach(var prop in commonProperties)
        {
            source.Append($@"
        public {prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {prop.Name} => Match({string.Join(",", Enumerable.Range(0, typeArguments.Length).Select(_ => $"x => x.{prop.Name}"))});
");
        }

        source.Append(@"    }
}");

        var src = source.ToString();
        return src;
    }

    private bool HasErrors(SourceProductionContext context, SymbolWithAttribute symbol)
    {
        var (classSymbol, attributeData) = symbol;
        var attributeLocation = classSymbol.Locations.FirstOrDefault() ?? Location.None;

        if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.TopLevelError, classSymbol);
            return true;
        }

        if (classSymbol.BaseType is not null && classSymbol.BaseType.Name != "Object")
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.WrongBaseType, classSymbol);
            return true;
        }

        var typeArguments = attributeData.AttributeClass!.TypeArguments;

        foreach (var typeSymbol in typeArguments)
        {
            if (typeSymbol.Name == nameof(Object))
            {
                CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.ObjectNotValidType, classSymbol);
                return true;
            }

            if (typeSymbol.TypeKind == TypeKind.Interface)
            {
                CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.InterfaceNotValidType, classSymbol);
                return true;
            }
        }

        var typeArgLookup = typeArguments.ToLookup(x => x, SymbolEqualityComparer.Default);

        if (typeArgLookup.Any(a => a.Count() > 1))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.RepeatedTypeSymbols, classSymbol);
            return true;
        }

        return false;
    }

    private static ImmutableArray<IPropertySymbol> GetCommonProperties(ImmutableArray<ITypeSymbol> typeArguments)
    {
        var typeProperties = typeArguments.SelectMany(t => t.GetPublicProperties()).ToLookup(x => x.Name);

        var commonProperties = typeProperties.Where(g => g.Count() == typeArguments.Length && g.All(s => s.Type.Equals(g.First().Type, SymbolEqualityComparer.IncludeNullability)))
            .Select(x => x.First())
            .ToImmutableArray();

        return commonProperties;
    }
}