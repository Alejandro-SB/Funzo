using Funzo.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Funzo.SourceGenerators.Generators.Unions;

internal class UnionGenerator : GeneratorBase
{
    internal override string? GetSource(SourceProductionContext context, MarkedType type)
    {
        if (HasErrors(context, type))
        {
            return null;
        }

        var commonProperties = GetCommonProperties(type.AttributeTypeArguments);

        var classSymbol = type.Symbol;
        var className = $"{classSymbol.Name}";
        var typeArguments = type.AttributeTypeArguments;

        StringBuilder source = new($@"// <auto-generated />

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{");

        // Add all needed upper classes
        foreach (var containingType in type.ContainerClasses)
        {
            var isStatic = type.Symbol.ContainingType!.IsStatic ? "static " : "";

            source.AppendLine($"{isStatic}partial class {containingType.Name} {{");
        }

        source.AppendLine($@"         partial class {className} : global::{FunzoAttributeSources.AttributeNamespace}.Union{typeArguments.OpenGenericPart()}
    {{");

        foreach (var typeArgument in typeArguments)
        {
            source.Append($@"
        public {classSymbol.Name}({typeArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) : base(_) {{}}
        public static implicit operator {className}({typeArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) => new {className}(_);
");
        }

        foreach (var prop in commonProperties)
        {
            source.Append($@"
        public {prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {prop.Name} => Match({string.Join(",", Enumerable.Range(0, typeArguments.Length).Select(_ => $"x => x.{prop.Name}"))});
");
        }

        // Close all the braces opened for parent classes
        source.AppendLine(new string('}', type.ContainerClasses.Count));

        source.Append(@"    }
}");

        var src = source.ToString();
        return src;
    }

    private bool HasErrors(SourceProductionContext context, MarkedType type)
    {
        var symbol = type.Symbol;

        if (!IsSymbolTopLevelOrInsidePartialClasses(symbol))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.TopLevelError, symbol);
            return true;
        }

        if (IsSymbolInheritingFromOtherClasses(symbol))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.WrongBaseType, symbol);
            return true;
        }


        if (IsAnyTypeArgumentObject(type.AttributeTypeArguments))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.ObjectNotValidType, symbol);
            return true;
        }

        if (IsAnyTypeArgumentAnInterface(type.AttributeTypeArguments))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.InterfaceNotValidType, symbol);
            return true;
        }

        if (IsAnyTypeRepeatedInUnion(type.AttributeTypeArguments))
        {
            CreateDiagnosticError(context, FunzoDiagnosticDescriptors.Union.RepeatedTypeSymbols, symbol);
            return true;
        }

        return false;
    }

    private static ImmutableArray<IPropertySymbol> GetCommonProperties(ImmutableArray<ITypeSymbol> typeArguments)
    {
        var typeProperties = typeArguments.SelectMany(t => t.GetPublicProperties()).ToLookup(x => x.Name);

        var commonProperties = typeProperties.Where(g => g.Count() == typeArguments.Length && g.All(s => s.Type.Equals(g.First().Type, SymbolEqualityComparer.IncludeNullability)))
            .Select(x => x.First())
            .ToImmutableArray();

        return commonProperties;
    }

    private static bool IsSymbolTopLevelOrInsidePartialClasses(INamedTypeSymbol type)
        => !(type.ContainingSymbol.Equals(type.ContainingNamespace, SymbolEqualityComparer.Default) && type.ContainingType is { } containerType
            && containerType.DeclaringSyntaxReferences.Any(syntax =>
                syntax.GetSyntax() is BaseTypeDeclarationSyntax declaration
                && !declaration.Modifiers.Any(mod => mod.IsKind(SyntaxKind.PartialKeyword))));

    private static bool IsSymbolInheritingFromOtherClasses(INamedTypeSymbol symbol)
        => symbol.BaseType is not null && symbol.BaseType.Name != "Object";

    private static bool IsAnyTypeArgumentObject(ImmutableArray<ITypeSymbol> typeArguments)
        => typeArguments.Any(a => a.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "object");

    private static bool IsAnyTypeArgumentAnInterface(ImmutableArray<ITypeSymbol> typeArguments)
        => typeArguments.Any(t => t.TypeKind == TypeKind.Interface);

    private static bool IsAnyTypeRepeatedInUnion(ImmutableArray<ITypeSymbol> typeArguments)
        => typeArguments.ToLookup(x => x, SymbolEqualityComparer.Default).Any(g => g.Count() > 1);
}